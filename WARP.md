# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Key commands and workflows

### Kubernetes deployment from a machine with kubectl access

These commands assume your `kubectl` context is already configured to point at the homelab cluster.

- Apply all cluster components (namespaces, networking, platform, monitoring, microservices):
  - `./ci-cd/scripts/deploy-all.sh`
- Check cluster and application status:
  - `./ci-cd/scripts/status.sh`
- Apply only specific layers (mirrors what the deploy script does):
  - Namespaces: `kubectl apply -f kubernetes/namespaces/`
  - Networking (Calico CNI, ingress-nginx, MetalLB): `kubectl apply -f kubernetes/networking/`
  - Platform config (global config, ingress rules, shared resources): `kubectl apply -f kubernetes/platform/`
  - Microservices (workload Deployments/Services/HPAs): `kubectl apply -f kubernetes/microservices/`
  - Monitoring stack (Prometheus, Grafana, etc. when defined): `kubectl apply -f kubernetes/monitoring/`

### Microservice development (Node.js services)

Each business microservice lives under `kubernetes/microservices/<service-name>/` and is a small Node/Express service with its own `package.json` and `Dockerfile`.

Common patterns (per-service commands must be run from that service directory):

- Install dependencies (any service):
  - `cd kubernetes/microservices/<service-name>/ && npm install`

- Lead Service (`kubernetes/microservices/lead-service/`):
  - Start (prod-like): `npm start`
  - Run with auto-reload for local dev: `npm run dev`

- User Service (`kubernetes/microservices/user-service/`):
  - Start (prod-like): `npm start`
  - Run with auto-reload for local dev: `npm run dev`

- Product Service (`kubernetes/microservices/product-service/`):
  - Start API: `npm start`
  - Apply database migrations (Prisma): `npm run db:deploy`

- Seller Service (`kubernetes/microservices/seller-service/`):
  - Start API: `npm start`

At the time of writing there are no test or lint scripts defined in these `package.json` files; if you add Jest/other tooling, update this file with concrete `npm test` commands (including how to run a single test).

### CI/CD (GitHub Actions)

All CI/CD workflows live under `ci-cd/github-actions/` and are oriented around Docker image build/push and manifest-based deployment.

- **Build and Push Docker Image** (`ci-cd/github-actions/build-and-push.yml`)
  - Triggered on pushes to `main` touching `apps/**` or via manual dispatch.
  - Builds `apps/api-gateway` using its `Dockerfile` and pushes to Docker Hub as `harshsennnn/api-gateway:latest`.
  - A local equivalent (if you need it outside Actions) would be:
    - `docker build -t harshsennnn/api-gateway:latest -f apps/api-gateway/Dockerfile apps/api-gateway`

- **Deploy to Homelab Kubernetes** (`ci-cd/github-actions/deploy-to-homelab.yml`)
  - Triggered on pushes to `main` touching `kubernetes/**` or `ci-cd/**`, or via manual dispatch.
  - Sets up `kubectl` using a `KUBECONFIG` secret, verifies `kubectl get nodes`, then sequentially applies:
    - `kubernetes/namespaces/`
    - `kubernetes/networking/` and `kubernetes/platform/`
    - `kubernetes/microservices/`
    - `kubernetes/monitoring/`

### Cluster bootstrap helpers (kubeadm)

Bare-metal cluster lifecycle is managed explicitly via kubeadm, not automated by CI/CD.

- Control plane init configuration: `infrastructure/kubeadm/init-config.yaml`
  - Describes `InitConfiguration`, `ClusterConfiguration`, and `KubeletConfiguration` for a kubeadm-based control plane on Raspberry Pi (ARM64), using containerd and `systemd` cgroup driver.
  - Typical usage is to run (on the future control-plane node):
    - `sudo kubeadm init --config infrastructure/kubeadm/init-config.yaml`

- Worker node join helper: `infrastructure/kubeadm/join-worker.sh`
  - Must be run as root (`sudo ./infrastructure/kubeadm/join-worker.sh`).
  - Handles homelab-specific prerequisites on the worker:
    - Disables swap and comments it out from `/etc/fstab`.
    - Loads `overlay` and `br_netfilter` kernel modules.
    - Sets required sysctl values for Kubernetes networking (bridge netfilter, IP forwarding) and applies them via `sysctl --system`.
  - After that it prompts you to paste the `kubeadm join ...` command generated by the control-plane node and then executes it.

## High-level architecture and layout

This repository is primarily **infrastructure-as-code plus minimal service code** for a bare-metal Raspberry Pi Kubernetes homelab. The code is organized around four main concerns: node bootstrap, cluster networking/platform, application workloads, and CI/CD.

### Top-level structure

- `README.md` – High-level description of the homelab, hardware topology, and goals (bare-metal Kubernetes with kubeadm, Calico, ingress-nginx, MetalLB, Prometheus/Grafana, and GitHub Actions-based workflows).
- `infrastructure/` – Node-level bootstrap and kubeadm configuration.
- `kubernetes/` – All cluster-level manifests (namespaces, networking, platform config/ingress, microservices, monitoring).
- `ci-cd/` – GitHub Actions workflows and small kubectl helper scripts.

### Node and cluster bootstrap (`infrastructure/`)

- `infrastructure/kubeadm/init-config.yaml`
  - Defines the cluster name (`raspberrypi-homelab`), control-plane endpoint, Kubernetes version, pod/service CIDRs, and kubelet cgroup driver.
  - This file is the single source of truth for kubeadm init parameters; do not hard-code flags elsewhere.

- `infrastructure/kubeadm/join-worker.sh`
  - Encapsulates the required OS prep to make a worker node join-safe (swap off, kernel modules, sysctls) and then runs the pasted `kubeadm join` command.
  - Future changes to worker prerequisites should be made here so that all nodes are prepared consistently.

### Kubernetes manifests (`kubernetes/`)

The `kubernetes/` tree is laid out by concern rather than by environment; all manifests target the homelab cluster.

- `kubernetes/namespaces/`
  - Defines logical separation for different concerns:
    - `platform` – shared platform components (ingress controller, config, etc.).
    - `microservices-app` – business microservices and their ingress.
    - `monitoring` – Prometheus/Grafana and related monitoring workloads.

- `kubernetes/networking/`
  - `cni/calico-rpi-homelab.yaml` – vendor manifest for Calico CNI tailored for this cluster. It installs Calico components, CRDs, and CNI configuration for pod networking.
  - `ingress-nginx/ingress-controller.yml` – deployment and service for the NGINX ingress controller used as the cluster ingress entry point.
  - `metallb/metallb.yaml` and `metallb/ip-pool.yml` – installs MetalLB and configures the address pool for bare-metal LoadBalancer Services so that services can be exposed on LAN IPs.

- `kubernetes/platform/`
  - `config/global-config.yml`
    - A `ConfigMap` named `global-config` in the `microservices-app` namespace.
    - Holds shared environment and internal service URLs such as `AUTH_SERVICE_URL`, `USER_SERVICE_URL`, `PRODUCT_SERVICE_URL`, `ORDER_SERVICE_URL`, along with `APP_ENV` and `LOG_LEVEL`.
    - Intended to be mounted or injected into all microservices so that cross-service URLs and environment are centrally managed.
  - `ingress/microservices-app-ingress.yml`
    - A single NGINX `Ingress` resource (`microservices-app-ingress`) in the `microservices-app` namespace.
    - Routes the host `microservices.local` to individual services using regex-based path prefixes like `/auth`, `/users`, `/products`, `/orders` and rewrites paths for the backing services.
    - This is the primary HTTP entry point into the microservices application when combined with MetalLB and the ingress-nginx LoadBalancer Service.

- `kubernetes/microservices/`
  - Each subdirectory represents a specific microservice or edge component:
    - `api-gateway/` – Kubernetes-facing gateway (Deployment/Service/HPA manifests); the Docker image is built from `apps/api-gateway` via CI.
    - `lead-service/`, `product-service/`, `seller-service`, `user-service/` – individual Node.js services with their own `Dockerfile` and `package.json`.
  - Typical flow:
    1. Build/push service image (locally or via GitHub Actions).
    2. Update the image tag in the relevant `Deployment` manifest.
    3. Apply manifests in that service’s directory or via the aggregate `kubectl apply -f kubernetes/microservices/`.

- `kubernetes/monitoring/`
  - Contains the monitoring stack (e.g., Prometheus and Grafana) described in `README.md`.
  - These manifests are applied after the core networking and platform components so that telemetry covers both infrastructure and workloads.

### CI/CD and helper scripts (`ci-cd/`)

- `ci-cd/github-actions/build-and-push.yml`
  - Encodes how the API gateway image should be built for ARM64-compatible nodes and pushed to Docker Hub.
  - Serves as the canonical reference for build arguments, Dockerfile location, and image tags; align local builds with this file.

- `ci-cd/github-actions/deploy-to-homelab.yml`
  - Documents the intended end-to-end deployment sequence to the homelab cluster using `kubectl`.
  - The steps here should stay in sync with `ci-cd/scripts/deploy-all.sh`; when adding new top-level manifest directories under `kubernetes/`, update both.

- `ci-cd/scripts/deploy-all.sh`
  - Local convenience wrapper to apply namespace, networking, platform, monitoring, and microservices manifests in a fixed order.
  - Safe to re-run; relies on `kubectl apply` being idempotent.

- `ci-cd/scripts/status.sh`
  - Minimal observability helper that prints:
    - Overall node status (`kubectl get nodes`).
    - Pods in the `platform`, `microservices-app`, and `monitoring` namespaces.
  - Extend this script (rather than inventing new ad-hoc status commands) when you add more namespaces or key workloads that should be monitored.

### Documentation and diagrams

- Architecture and traffic-flow diagrams referenced from `README.md` live under:
  - `docs/architecture/Architecture.png` – high-level cluster and homelab topology.
  - `kubernetes/networking/Trafficflow.png` – network and ingress/egress flow through Calico, MetalLB, and ingress-nginx.

Use these diagrams in conjunction with the `kubernetes/` manifests to understand how traffic enters the cluster (via MetalLB IPs and ingress-nginx) and is routed to services in the `microservices-app` namespace.
